<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Ping Pong 2P</title>
  <style>
    * { box-sizing: border-box; margin:0; padding:0; }
    body, html {
      width:100%; height:100%;
      background: #111;
      display: flex; justify-content: center; align-items: center;
      color: #eee; font-family: sans-serif;
    }
    canvas {
      border: 3px dashed #0ff;
      background: #222;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="c" width="900" height="600"></canvas>
  <script>
  const CANVAS  = document.getElementById('c');
  const ctx     = CANVAS.getContext('2d');
  const W       = CANVAS.width, H = CANVAS.height;
  const PAD_W   = 12, PAD_H = 100;
  const BALL_R  = 10;
  const PADDLE_SPEED = 400;        // px/sec
  const BALL_SPEED0  = 350;        // serve speed
  const BALL_SPEED_INC = 20;       // on paddle hit
  const MAX_SCORE = 10;

  let paddles = {
    left:  (H - PAD_H)/2,
    right: (H - PAD_H)/2
  };
  let ball = { x: W/2, y: H/2, vx:0, vy:0, speed: BALL_SPEED0 };
  let scores = { left:0, right:0 };

  let keys = {};                   // keyboard state
  let dragging = null;             // 'left'|'right' for mouse/touch
  let lastTS = 0;
  let countdown = 3, inCountdown = true;

  // UTILS
  function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
  function resetBall(){
    ball.x = W/2; ball.y = H/2;
    ball.speed = BALL_SPEED0;
    // random angle between ±45° towards last scorer
    let angle = (Math.random()*Math.PI/4) - (Math.PI/8);
    let dir = (scores.left > scores.right ? 1 : -1);
    ball.vx = dir * ball.speed * Math.cos(angle);
    ball.vy = ball.speed * Math.sin(angle);
  }
  // COUNTDOWN
  function startCountdown(){
    inCountdown = true;
    countdown = 3;
    let iv = setInterval(()=>{
      countdown--;
      if(countdown<=0){
        clearInterval(iv);
        inCountdown = false;
        resetBall();
      }
    }, 1000);
  }

  // DRAW
  function draw(){
    ctx.clearRect(0,0,W,H);
    // center line
    ctx.strokeStyle = '#444'; ctx.setLineDash([10,10]);
    ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke();
    ctx.setLineDash([]);

    // paddles
    ctx.fillStyle = '#0ff';
    ctx.fillRect(0, paddles.left, PAD_W, PAD_H);
    ctx.fillStyle = '#f0f';
    ctx.fillRect(W-PAD_W, paddles.right, PAD_W, PAD_H);

    // ball
    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, BALL_R,0,Math.PI*2);
    ctx.fill();

    // scores
    ctx.fillStyle = '#eee';
    ctx.font = '48px monospace';
    ctx.fillText(scores.left, W/4, 60);
    ctx.fillText(scores.right, W*3/4, 60);

    // countdown overlay
    if(inCountdown){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#0ff';
      ctx.font = '120px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(countdown > 0 ? countdown : 'Go!', W/2, H/2 + 40);
      ctx.textAlign = 'start';
    }
  }

  // UPDATE
  function update(dt){
    // paddles: keyboard
    if(keys['w']) paddles.left  = clamp(paddles.left  - PADDLE_SPEED*dt, 0, H - PAD_H);
    if(keys['s']) paddles.left  = clamp(paddles.left  + PADDLE_SPEED*dt, 0, H - PAD_H);
    if(keys['ArrowUp'])   paddles.right = clamp(paddles.right - PADDLE_SPEED*dt, 0, H - PAD_H);
    if(keys['ArrowDown']) paddles.right = clamp(paddles.right + PADDLE_SPEED*dt, 0, H - PAD_H);

    // ball movement
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // top/bottom bounce
    if(ball.y < BALL_R){ ball.y = BALL_R; ball.vy *= -1; }
    if(ball.y > H-BALL_R){ ball.y = H-BALL_R; ball.vy *= -1; }

    // left paddle collision
    if(ball.x - BALL_R < PAD_W){
      if(ball.y > paddles.left && ball.y < paddles.left + PAD_H){
        // compute bounce angle
        let rel = (ball.y - (paddles.left + PAD_H/2)) / (PAD_H/2);
        let ang = rel * Math.PI/4; // max 45°
        ball.speed = Math.min(ball.speed + BALL_SPEED_INC, 800);
        ball.vx =  ball.speed * Math.cos(ang);
        ball.vy =  ball.speed * Math.sin(ang);
        ball.x = PAD_W + BALL_R; // prevent sticking
      } else {
        // score right
        scores.right++;
        if(scores.right >= MAX_SCORE) return gameOver();
        startCountdown();
      }
    }

    // right paddle
    if(ball.x + BALL_R > W - PAD_W){
      if(ball.y > paddles.right && ball.y < paddles.right + PAD_H){
        let rel = (ball.y - (paddles.right + PAD_H/2)) / (PAD_H/2);
        let ang = rel * Math.PI/4;
        ball.speed = Math.min(ball.speed + BALL_SPEED_INC, 800);
        ball.vx = -ball.speed * Math.cos(ang);
        ball.vy =  ball.speed * Math.sin(ang);
        ball.x = W - PAD_W - BALL_R;
      } else {
        scores.left++;
        if(scores.left >= MAX_SCORE) return gameOver();
        startCountdown();
      }
    }
  }

  // GAME OVER
  function gameOver(){
    inCountdown = true;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#f00';
    ctx.font = '80px monospace';
    ctx.textAlign = 'center';
    let winner = scores.left > scores.right ? 'Left Player' : 'Right Player';
    ctx.fillText(`${winner} Wins!`, W/2, H/2);
    // restart after 3s
    setTimeout(()=>{
      scores.left = scores.right = 0;
      startCountdown();
      lastTS = 0;
      requestAnimationFrame(loop);
    }, 3000);
  }

  // MAIN LOOP
  function loop(ts){
    if(!lastTS) lastTS = ts;
    const dt = (ts - lastTS)/1000;
    lastTS = ts;
    if(!inCountdown) update(dt);
    draw();
    if(scores.left < MAX_SCORE && scores.right < MAX_SCORE)
      requestAnimationFrame(loop);
  }

  // INPUT HANDLERS
  window.addEventListener('keydown', e=> keys[e.key] = true );
  window.addEventListener('keyup',   e=> keys[e.key] = false );

  // MOUSE → drag paddle
  CANVAS.addEventListener('mousedown', e=>{
    let y = e.offsetY;
    if(e.offsetX < W/2 && y > paddles.left && y < paddles.left+PAD_H) dragging='left';
    if(e.offsetX > W/2 && y > paddles.right && y < paddles.right+PAD_H) dragging='right';
  });
  window.addEventListener('mousemove', e=>{
    if(!dragging) return;
    const rect = CANVAS.getBoundingClientRect();
    let y = e.clientY - rect.top - PAD_H/2;
    if(dragging==='left')  paddles.left  = clamp(y,0,H-PAD_H);
    if(dragging==='right') paddles.right = clamp(y,0,H-PAD_H);
  });
  window.addEventListener('mouseup', ()=> dragging = null );

  // TOUCH → drag
  CANVAS.addEventListener('touchstart', e=>{
    e.preventDefault();
    let t = e.touches[0], rect = CANVAS.getBoundingClientRect();
    let x = t.clientX - rect.left, y = t.clientY - rect.top;
    if(x < W/2 && y > paddles.left && y < paddles.left+PAD_H) dragging='left';
    if(x > W/2 && y > paddles.right && y < paddles.right+PAD_H) dragging='right';
  }, {passive:false});
  CANVAS.addEventListener('touchmove', e=>{
    e.preventDefault();
    if(!dragging) return;
    let t = e.touches[0], rect = CANVAS.getBoundingClientRect();
    let y = t.clientY - rect.top - PAD_H/2;
    if(dragging==='left')  paddles.left  = clamp(y,0,H-PAD_H);
    if(dragging==='right') paddles.right = clamp(y,0,H-PAD_H);
  }, {passive:false});
  CANVAS.addEventListener('touchend', ()=> dragging = null );

  // START
  startCountdown();
  requestAnimationFrame(loop);

  </script>
</body>
</html>
