<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ping Pong with Buffs</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;}
    body{background:#111;color:#fff;font-family:sans-serif;overflow:hidden;position:relative;}
    body.theme-neon{background:#000;color:#0ff;}
    #canvas{display:block;margin:0 auto;background:#222;}
    #ui{position:absolute;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:2rem;font-size:1.2rem;z-index:2;}
    #controls{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);display:none;
      width:80%;height:60px;background:rgba(255,255,255,0.1);border-radius:30px;touch-action:none;z-index:2;}
    @media(max-width:600px){
      #controls{width:60px;height:80%;left:auto;right:10px;bottom:auto;top:50%;transform:translateY(-50%);}
    }
    #overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:#000;opacity:0;pointer-events:none;transition:opacity .3s;}
    #restartBtn{position:absolute;top:10px;right:10px;padding:.5rem 1rem;background:#c00;border:none;color:#fff;cursor:pointer;z-index:2;}
  </style>
</head>
<body>

  <canvas id="canvas" width="900" height="500"></canvas>
  <div id="ui"><div>Score: <span id="score">0</span></div></div>
  <div id="controls"></div>
  <div id="overlay"></div>
  <button id="restartBtn" style="display:none;">Restart</button>

  <script>
  (()=>{
    // --- setup ---
    const params=new URLSearchParams(location.search);
    const theme=params.get('theme')||'dark';
    document.body.classList.add('theme-'+theme);

    const canvas=document.getElementById('canvas'), ctx=canvas.getContext('2d');
    const W=canvas.width,H=canvas.height;
    const PADDLE_W=12, PADDLE_H0=100, BALL_R=10;
    let PADDLE_H=PADDLE_H0;

    const scoreEl=document.getElementById('score');
    const controls=document.getElementById('controls');
    const overlay=document.getElementById('overlay');
    const restartBtn=document.getElementById('restartBtn');

    // game state
    let score=0, playing=false;
    let paddleY=(H-PADDLE_H)/2;
    let balls=[{x:W/2,y:H/2,dx:5,dy:3}];
    let obstacles=[]; // {x,y,w,h,ttl}

    // buffs on field
    let buffs=[]; // {x,y,type}
    const BUFF_R=12;
    const BUFF_TYPES=[
      {type:'double', color:'#0f0'},
      {type:'grow',   color:'#ff0'},
      {type:'dark',   color:'#800'},
      {type:'speed',  color:'#0ff'},
      {type:'block',  color:'#888'},
    ];
    // active effects
    let effects={double:0,grow:0,dark:0};

    // controls
    let ctrlMode=('ontouchstart' in window)?'touch':'mouse';
    setupControls();

    function setupControls(){
      if(ctrlMode==='mouse'){
        canvas.style.cursor='none';
        canvas.addEventListener('mousemove',e=>{
          const r=canvas.getBoundingClientRect();
          paddleY=Math.max(0,Math.min(H-PADDLE_H, e.clientY-r.top-PADDLE_H/2));
        });
      } else {
        controls.style.display='block';
        let drag=false;
        controls.addEventListener('pointerdown',()=>drag=true);
        controls.addEventListener('pointerup',()=>drag=false);
        controls.addEventListener('pointermove',e=>{
          if(!drag)return;
          const r=controls.getBoundingClientRect();
          const pct=(window.matchMedia('(max-width:600px)').matches)
            ?(e.clientY-r.top)/r.height
            :(e.clientX-r.left)/r.width;
          paddleY=Math.max(0,Math.min(H-PADDLE_H,pct*(H-PADDLE_H)));
        });
      }
    }

    // spawn buffs & obstacles
    setInterval(()=>spawnBuff(), random(8000,15000));
    setInterval(()=>spawnObstacle(), random(10000,20000));

    function spawnBuff(){
      const b=BUFF_TYPES[random(0,BUFF_TYPES.length-1)];
      buffs.push({x:random(BUFF_R,W-BUFF_R), y:random(BUFF_R,H-BUFF_R), type:b.type, color:b.color});
    }
    function spawnObstacle(){
      obstacles.push({x:random(W/3,2*W/3), y:random(H/4,3*H/4), w:30, h:100, ttl:10000});
    }

    // main loop
    let last=0;
    function loop(ts){
      if(!playing)return;
      const dt=(ts-last)/1000; last=ts;

      // move balls
      balls.forEach(b=>{
        b.x+=b.dx; b.y+=b.dy;
        // walls
        if(b.y< BALL_R||b.y>H-BALL_R) b.dy*=-1;
        // paddle
        if(b.x<=PADDLE_W+BALL_R){
          if(b.y>=paddleY&&b.y<=paddleY+PADDLE_H) b.dx*=-1;
          else endRound();
        }
        // obstacles
        obstacles.forEach(o=>{
          if(b.x>o.x&&b.x<o.x+o.w&&b.y>o.y&&b.y<o.y+o.h){
            // simple reflect
            b.dx*=-1; b.dy*=-1;
          }
        });
      });

      // buff pickup
      buffs=buffs.filter(buff=>{
        let hit=false;
        balls.forEach(b=>{
          const dx=b.x-buff.x, dy=b.y-buff.y;
          if(Math.hypot(dx,dy)<BALL_R+BUFF_R){
            apply(buff.type);
            hit=true;
          }
        });
        return !hit;
      });

      // update effects
      Object.keys(effects).forEach(k=>{
        if(effects[k]>0){
          effects[k]-=dt*1000;
          if(effects[k]<=0) removeEffect(k);
        }
      });
      // obstacles ttl
      obstacles=obstacles.filter(o=>(o.ttl-=dt*1000)>0);

      // draw
      render();
      requestAnimationFrame(loop);
    }

    function render(){
      ctx.clearRect(0,0,W,H);
      // paddle
      ctx.fillStyle='#0ff';
      ctx.fillRect(0,paddleY,PADDLE_W,PADDLE_H);
      // balls
      ctx.fillStyle='#ff0';
      balls.forEach(b=>{ctx.beginPath(); ctx.arc(b.x,b.y,BALL_R,0,2*Math.PI); ctx.fill();});
      // buffs
      buffs.forEach(b=>{
        ctx.fillStyle=b.color;
        ctx.beginPath(); ctx.arc(b.x,b.y,BUFF_R,0,2*Math.PI); ctx.fill();
      });
      // obstacles
      ctx.fillStyle='#888';
      obstacles.forEach(o=>ctx.fillRect(o.x,o.y,o.w,o.h));
      // screen dark
      if(effects.dark>0) overlay.style.opacity=0.6; else overlay.style.opacity=0;
    }

    function apply(type){
      switch(type){
        case 'double':
          if(!effects.double){
            const clones=balls.map(b=>({...b,dx:-b.dx,dy:-b.dy}));
            balls.push(...clones);
          }
          effects.double=10000; break;
        case 'grow':
          if(!effects.grow){ PADDLE_H*=1.5; }
          effects.grow=8000; break;
        case 'dark':
          effects.dark=5000; break;
        case 'speed':
          balls.forEach(b=>{b.dx*=1.2; b.dy*=1.2;});
          break;
        case 'block':
          // nothing extra
          break;
      }
    }
    function removeEffect(k){
      if(k==='double'){ balls=balls.slice(0,1); }
      if(k==='grow'){ PADDLE_H=PADDLE_H0; }
      if(k==='dark'){ overlay.style.opacity=0; }
      effects[k]=0;
    }

    function endRound(){
      score++; scoreEl.textContent=score;
      reset();
    }

    function reset(){
      balls=[{x:W/2,y:H/2,dx:5,dy:3}];
      paddleY=(H-PADDLE_H0)/2; PADDLE_H=PADDLE_H0;
      buffs=[]; obstacles=[];
    }

    function start(){
      reset(); playing=true; last=performance.now();
      requestAnimationFrame(loop);
    }

    restartBtn.addEventListener('click',()=>{
      score=0; scoreEl.textContent=0;
      restartBtn.style.display='none';
      start();
    });

    // helpers
    function random(a,b){return Math.floor(Math.random()*(b-a)+a);}
    // start now
    start();
  })();
  </script>
</body>
</html>
