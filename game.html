<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Ping Pong – TOFAŞ CAE Edition</title>
  <style>
    /* Reset & globals */
    * { margin:0; padding:0; box-sizing:border-box; user-select:none; }
    body {
      background: url('background.png') center/cover no-repeat;
      font-family: Arial, sans-serif;
      overflow: hidden;
      position: relative;
    }
    canvas { display:block; margin: 0 auto; background: rgba(0,0,0,0.4); }

    /* UI bar */
    #ui {
      position: absolute; top:0; left:50%; transform:translateX(-50%);
      width:1100px; height:50px; display:flex;
      align-items:center; justify-content: space-between;
      padding:0 1rem; background:rgba(0,0,0,0.7); color:#0ff;
      font-size:1.2rem; z-index:10;
    }
    #ui div { display:flex; align-items:center; gap:.5rem; }
    #timer { font-family: monospace; }

    /* Pause & restart */
    #pauseBtn, #restartBtn {
      background: #0ff; color:#000; border:none;
      padding:.3rem .6rem; cursor:pointer; font-size:1rem;
      border-radius:4px;
    }
    #restartBtn { display:none; }

    /* Touch controls */
    #touchControls {
      display:none;
      position:absolute; bottom:0; left:50%; transform:translateX(-50%);
      width:1100px; height:80px; background:rgba(255,255,255,0.2);
      border-radius:40px; touch-action:none; z-index:10;
    }

    /* Dark overlay for screen-dark buff */
    #darkOverlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:rgba(0,0,0,0.6); pointer-events:none; opacity:0;
      transition:opacity .3s;
      z-index:5;
    }

    /* End‐of‐game modal */
    #overlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:rgba(0,0,0,0.8); display:flex;
      align-items:center; justify-content:center;
      color:#0ff; font-size:2rem; flex-direction:column;
      visibility:hidden; z-index:20;
    }
  </style>
</head>
<body>

  <div id="ui">
    <div>Player: <span id="score1">0</span></div>
    <div id="timer">03:00</div>
    <div>CPU: <span id="score2">0</span></div>
    <button id="pauseBtn">⏸️</button>
    <button id="restartBtn">↻ Yeniden</button>
  </div>

  <canvas id="gameCanvas" width="1100" height="600"></canvas>
  <div id="darkOverlay"></div>
  <div id="touchControls"></div>

  <div id="overlay">
    <p id="endText"></p>
    <button id="restartBtn2">Yeniden Başlat</button>
  </div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx    = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // UI
  const score1El = document.getElementById('score1');
  const score2El = document.getElementById('score2');
  const timerEl  = document.getElementById('timer');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const restartBtn2 = document.getElementById('restartBtn2');
  const overlay = document.getElementById('overlay');
  const endText = document.getElementById('endText');
  const darkOv  = document.getElementById('darkOverlay');
  const touchControls = document.getElementById('touchControls');

  // Game constants
  const P_H0 = 100, P_W=12, R0=12;
  const BUFF_DURATION=6000, BUFF_SPAWN=15000;
  const GAME_TIME = 180; // seconds

  // State
  let state = {
    balls: [],
    p1Y: (H-P_H0)/2,
    p2Y: (H-P_H0)/2,
    score1: 0, score2: 0,
    time: GAME_TIME,
    buffs: [],
    effects: []
  };
  let last = performance.now();
  let paused = false;

  // --- initialize
  function resetBall(){
    state.balls = [{
      x: W/2, y: H/2,
      dx: 6*(Math.random()<.5?1:-1),
      dy: 4*(Math.random()<.5?1:-1)
    }];
  }
  resetBall();
  // spawn buffs
  function spawnBuff(){
    const types = ['double','grow','shrink','fast','dark'];
    const t = types[Math.floor(Math.random()*types.length)];
    state.buffs.push({
      type: t,
      x: 100 + Math.random()*(W-200),
      y:  50 + Math.random()*(H-100),
      t0: performance.now()
    });
  }
  setInterval(spawnBuff, BUFF_SPAWN);

  // Controls
  let ctrlMode = 'mouse';
  if('ontouchstart' in window){
    ctrlMode='touch';
    touchControls.style.display='block';
  }
  let dragging=false;
  touchControls.addEventListener('pointerdown',e=>dragging=true);
  touchControls.addEventListener('pointerup',e=>dragging=false);
  touchControls.addEventListener('pointermove',e=>{
    if(!dragging) return;
    const r = touchControls.getBoundingClientRect();
    const pct = (e.clientX - r.left)/r.width;
    state.p1Y = pct*(H-P_H0);
  });
  canvas.addEventListener('mousemove',e=>{
    if(ctrlMode==='mouse'){
      const r=canvas.getBoundingClientRect();
      state.p1Y = e.clientY - r.top - P_H0/2;
    }
  });

  pauseBtn.onclick = ()=> paused = !paused;
  restartBtn.onclick = restart;
  restartBtn2.onclick = restart;

  // Game loop
  function loop(now){
    const dt = (now-last)/1000;
    last = now;
    if(!paused){
      update(dt);
      render();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Update
  function update(dt){
    // timer
    state.time = Math.max(0,state.time - dt);
    const m = String(Math.floor(state.time/60)).padStart(2,'0'),
          s = String(Math.floor(state.time%60)).padStart(2,'0');
    timerEl.textContent = `${m}:${s}`;
    if(state.time===0){ endGame(); paused=true; }

    // CPU paddle
    const ball = state.balls[0];
    const diff = ball.y - (state.p2Y+P_H0/2);
    state.p2Y += diff*0.10; // reaction speed
    state.p2Y = Math.max(0,Math.min(H-P_H0, state.p2Y));

    // balls
    state.balls.forEach(b=>{
      b.x += b.dx; b.y += b.dy;
      // walls
      if(b.y< R0||b.y>H-R0) b.dy*=-1;
      // paddles
      if(b.x< P_W+R0){
        if(b.y>state.p1Y && b.y<state.p1Y+P_H0) b.dx*=-1;
        else { state.score2++; resetBall(); }
      }
      if(b.x>W-P_W-R0){
        if(b.y>state.p2Y && b.y<state.p2Y+P_H0) b.dx*=-1;
        else { state.score1++; resetBall(); }
      }
    });
    score1El.textContent = state.score1;
    score2El.textContent = state.score2;

    // buffs timeout
    const nowT = performance.now();
    state.buffs = state.buffs.filter(b=> nowT - b.t0 < BUFF_DURATION);
  }

  // Render
  function render(){
    ctx.clearRect(0,0,W,H);
    // paddles
    ctx.fillStyle='#0ff';
    ctx.fillRect(0, state.p1Y, P_W, P_H0);
    ctx.fillRect(W-P_W, state.p2Y, P_W, P_H0);
    // balls
    ctx.fillStyle='#ff0';
    state.balls.forEach(b=>{
      ctx.beginPath();
      ctx.arc(b.x,b.y,R0,0,2*Math.PI);
      ctx.fill();
    });
    // buffs
    state.buffs.forEach(b=>{
      const ico = {double:'#f0f',grow:'#0f0',shrink:'#f00',fast:'#ff0',dark:'#00f'}[b.type];
      ctx.fillStyle = ico;
      ctx.fillRect(b.x-8,b.y-8,16,16);
    });
    // dark overlay
    darkOv.style.opacity = state.effects.some(e=>e.type==='dark')? '1':'0';
    // clean expired effects
    const now = performance.now();
    state.effects = state.effects.filter(e=> now<e.exp);
  }

  // End game
  function endGame(){
    endText.textContent = state.score1>state.score2? 'KAZANDIN!' : 'CPU Kazandı';
    overlay.style.visibility='visible';
    restartBtn.style.display='inline-block';
  }
  function restart(){
    overlay.style.visibility='hidden';
    paused = false;
    state.score1=0; state.score2=0;
    state.time = GAME_TIME;
    resetBall();
  }
})();
</script>
</body>
</html>
