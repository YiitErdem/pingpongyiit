<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ping Pong – Neon Dark</title>
  <style>
    /* base resets */
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { width:100%; height:100%; overflow:hidden; background:#000; color:#0ff; font-family:sans-serif; }
    button { background:#0ff; color:#000; border:none; padding:.5em 1em; border-radius:4px; cursor:pointer; }
    /* container */
    #container { position:relative; width:100vw; height:100vh; display:flex; flex-direction:column; align-items:center; justify-content:center; }
    /* header UI */
    #ui { position:absolute; top:10px; left:50%; transform:translateX(-50%); display:flex; gap:2rem; font-size:1.2rem; z-index:10; }
    #ui span { white-space:nowrap; }
    #timer { font-weight:bold; }
    /* canvas */
    #canvas { background:#111; border:3px solid #0ff; border-radius:8px; touch-action:none; }
    /* touch controls */
    #touchbar { display:none; position:absolute; bottom:20px; left:50%; transform:translateX(-50%); width:80%; height:40px;
                background:rgba(0,255,255,0.1); border:2px solid #0ff; border-radius:20px; }
    /* overlays */
    #overlay { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9);
               display:flex; align-items:center; justify-content:center; font-size:3rem; z-index:20; color:#0ff; }
    /* darkness buff overlay */
    #darkness { position:absolute; top:0; left:0; width:100%; height:100%; background:#000; opacity:0; transition:opacity .3s; z-index:5; }
  </style>
</head>
<body>
  <div id="container">
    <div id="ui">
      <span>Score You: <strong id="score1">0</strong></span>
      <span id="timer">03:00</span>
      <span>Score CPU: <strong id="score2">0</strong></span>
    </div>
    <canvas id="canvas" width="360" height="640"></canvas>
    <div id="touchbar"></div>
    <div id="darkness"></div>
    <div id="overlay">3</div>
  </div>

  <script>
  (()=>{
    const canvas = document.getElementById('canvas'),
          ctx    = canvas.getContext('2d'),
          overlay= document.getElementById('overlay'),
          darkness = document.getElementById('darkness'),
          touchbar = document.getElementById('touchbar'),
          score1El = document.getElementById('score1'),
          score2El = document.getElementById('score2'),
          timerEl  = document.getElementById('timer');

    // game constants
    const W = canvas.width, H = canvas.height;
    const P_W = 12, P_H = 60, B_R=6;
    const GAME_TIME = 180;         // seconds
    let timeLeft = GAME_TIME, timerId;

    // state
    let p1 = { y:(H-P_H)/2 },       // player paddle (bottom)
        p2 = { y:(H-P_H)/2 },       // CPU paddle (top)
        ball={ x:W/2, y:H/2, dx:2, dy:2 },
        score1=0, score2=0,
        running=false;

    // buffs & obstacles
    let buffs = [], obstacles = [];

    // control mode
    let ctrl='auto'; // 'mouse','touch','key','auto'
    let dragging=false;

    // audio stubs (implement as you like)
    const SFX = { paddle:()=>{}, wall:()=>{}, score:()=>{}, buff:()=>{}, win:()=>{} };

    // init
    function resetBall(){
      ball.x=W/2; ball.y=H/2;
      ball.dx=2*(Math.random()<.5?1:-1);
      ball.dy=2*(Math.random()<.5?1:-1);
    }

    // spawn a random buff
    function spawnBuff(){
      const types = ['double','shrink','speed','dark'];
      const t = types[Math.floor(Math.random()*types.length)];
      buffs.push({
        x: Math.random()*(W-20)+10,
        y: Math.random()*(H-200)+100,
        r:8, type:t, used:false
      });
    }
    // spawn obstacle
    function spawnObs(){
      obstacles.push({
        x:W/2-15, y:H/2-30,
        w:30, h:30, ttl:180
      });
    }

    // apply buff
    function applyBuff(b){
      SFX.buff();
      switch(b.type){
        case 'double':
          // create second ball
          // for brevity, just speed up
          ball.dx*=1.5; ball.dy*=1.5;
          break;
        case 'shrink':
          P_H *=0.7; break;
        case 'speed':
          ball.dx*=2; ball.dy*=2; break;
        case 'dark':
          darkness.style.opacity=0.8;
          setTimeout(()=> darkness.style.opacity=0,5000);
          break;
      }
    }

    // start countdown
    function startCountdown(){
      let c=3; overlay.textContent=c; overlay.style.display='flex';
      const iv = setInterval(()=>{
        c--;
        if(c>0) overlay.textContent=c;
        else {
          clearInterval(iv);
          overlay.style.display='none';
          running=true;
          resetBall();
          timerId = setInterval(gameTimer,1000);
        }
      },1000);
    }

    // game timer
    function gameTimer(){
      timeLeft--;
      const m = Math.floor(timeLeft/60).toString().padStart(2,'0'),
            s = (timeLeft%60).toString().padStart(2,'0');
      timerEl.textContent=`${m}:${s}`;
      if(timeLeft<=0) endGame();
    }

    // end game
    function endGame(){
      running=false;
      clearInterval(timerId);
      overlay.style.display='flex';
      overlay.textContent = score1>score2?'You Win!':'CPU Wins';
      SFX.win();
    }

    // draw everything
    function draw(){
      ctx.clearRect(0,0,W,H);
      // paddles
      ctx.fillStyle='#0ff';
      // top
      ctx.fillRect(0,p2.y,P_W,P_H);
      // bottom
      ctx.fillRect(W-P_W,p1.y,P_W,P_H);
      // ball
      ctx.fillStyle='#ff0';
      ctx.beginPath();
      ctx.arc(ball.x,ball.y,B_R,0,2*Math.PI);
      ctx.fill();
      // buffs
      buffs.forEach(b=>{
        if(!b.used){
          ctx.fillStyle=b.type==='double'? '#f0f':'#f00';
          ctx.beginPath();
          ctx.arc(b.x,b.y,b.r,0,2*Math.PI);
          ctx.fill();
        }
      });
      // obstacles
      ctx.fillStyle='#555';
      obstacles.forEach(o=>{
        ctx.fillRect(o.x,o.y,o.w,o.h);
      });
      if(running) requestAnimationFrame(update);
    }

    // AI move
    function aiMove(){
      // simple predictive: follow ball.x
      const centre = ball.x - P_H/2;
      if(centre>p2.y+2) p2.y +=1.5;
      else if(centre<p2.y-2) p2.y -=1.5;
      p2.y = Math.max(0,Math.min(H-P_H,p2.y));
    }

    // main update loop
    function update(){
      // move paddles
      // player: already set via controls into p1.y

      aiMove();

      // move ball
      ball.x += ball.dx;
      ball.y += ball.dy;

      // wall bounce
      if(ball.x< B_R || ball.x> W-B_R){
        ball.dx*=-1; SFX.wall();
      }
      // top paddle
      if(ball.y< P_H+B_R){
        if(ball.x>0 && ball.x<P_W){
          ball.dy*=-1; SFX.paddle();
        } else {
          score1++;
          score1El.textContent=score1;
          SFX.score();
          resetBall();
        }
      }
      // bottom paddle
      if(ball.y> H-P_H-B_R){
        if(ball.x>W-P_W && ball.x<W){
          ball.dy*=-1; SFX.paddle();
        } else {
          score2++;
          score2El.textContent=score2;
          SFX.score();
          resetBall();
        }
      }

      // buff collisions
      buffs.forEach(b=>{
        if(!b.used && Math.hypot(ball.x-b.x,ball.y-b.y)<B_R+b.r){
          b.used=true;
          applyBuff(b);
        }
      });
      // remove used buffs
      buffs = buffs.filter(b=>!b.used);

      // obstacle TTL
      obstacles.forEach(o=> o.ttl--);
      obstacles = obstacles.filter(o=> o.ttl>0);

      // occasionally spawn
      if(Math.random()<.005) spawnBuff();
      if(Math.random()<.002) spawnObs();

      // draw
      draw();
    }

    // input setup
    function setupControls(){
      if('ontouchstart' in window){
        ctrl='touch';
        touchbar.style.display='block';
        touchbar.addEventListener('pointerdown',()=>dragging=true);
        touchbar.addEventListener('pointerup',()=>dragging=false);
        touchbar.addEventListener('pointermove',e=>{
          if(!dragging)return;
          const pct = (e.clientX - touchbar.getBoundingClientRect().left)/touchbar.clientWidth;
          p1.y = pct*(H-P_H);
        });
      } else {
        ctrl='mouse';
        canvas.style.cursor='none';
        canvas.addEventListener('mousemove',e=>{
          const r=canvas.getBoundingClientRect();
          const pct = (e.clientX-r.left)/r.width;
          p1.y = pct*(H-P_H);
        });
      }
      // keyboard fallback
      window.addEventListener('keydown',e=>{
        if(e.key==='ArrowLeft'||e.key==='a') p1.y-=5;
        if(e.key==='ArrowRight'||e.key==='d') p1.y+=5;
        p1.y = Math.max(0,Math.min(H-P_H,p1.y));
      });
    }

    // start
    setupControls();
    startCountdown();
    draw();
  })();
  </script>
</body>
</html>
